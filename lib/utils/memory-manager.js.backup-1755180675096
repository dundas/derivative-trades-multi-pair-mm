/**
 * MemoryManager
 * 
 * Centralized memory management for market maker components.
 * Handles efficient memory allocation, caching, and pruning for
 * critical data structures like orderbooks, trades, orders, and balances.
 * 
 * Features:
 * - Unified memory pool across market maker components
 * - Dynamic allocation based on component priority
 * - Intelligent caching with LRU eviction
 * - Memory monitoring and auto-pruning
 * - Configurable buffer sizes and retention policies
 */

import { TradingLogger } from '../../../utils/trading-logger.js';

/**
 * LRU (Least Recently Used) Cache implementation
 * for efficient data caching with automatic eviction
 */
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.cache = new Map();
    this.recentlyUsed = [];
  }

  /**
   * Get value from cache
   * @param {string} key - The key to look up
   * @returns {*} - The stored value or undefined
   */
  get(key) {
    if (!this.cache.has(key)) {
      return undefined;
    }
    
    // Move key to end of recentlyUsed list (most recently used)
    this.recentlyUsed = this.recentlyUsed.filter(k => k !== key);
    this.recentlyUsed.push(key);
    
    return this.cache.get(key);
  }

  /**
   * Put value in cache
   * @param {string} key - The key to store
   * @param {*} value - The value to store
   */
  put(key, value) {
    // Remove key from recently used if it exists
    this.recentlyUsed = this.recentlyUsed.filter(k => k !== key);
    
    // If at capacity, remove least recently used
    if (this.recentlyUsed.length >= this.capacity && !this.cache.has(key)) {
      const lruKey = this.recentlyUsed.shift();
      this.cache.delete(lruKey);
    }
    
    // Add new key-value pair
    this.cache.set(key, value);
    this.recentlyUsed.push(key);
  }

  /**
   * Delete key from cache
   * @param {string} key - The key to delete
   */
  delete(key) {
    this.cache.delete(key);
    this.recentlyUsed = this.recentlyUsed.filter(k => k !== key);
  }

  /**
   * Clear the cache
   */
  clear() {
    this.cache.clear();
    this.recentlyUsed = [];
  }

  /**
   * Get size of cache
   * @returns {number} - Number of items in cache
   */
  size() {
    return this.cache.size;
  }

  /**
   * Get all keys in cache
   * @returns {Array} - Array of keys
   */
  keys() {
    return Array.from(this.cache.keys());
  }

  /**
   * Get least recently used keys
   * @param {number} count - Number of keys to return
   * @returns {Array} - Array of least recently used keys
   */
  getLRUKeys(count) {
    return this.recentlyUsed.slice(0, count);
  }
}

/**
 * Buffer manager for specific data types
 */
class BufferManager {
  constructor(config) {
    this.name = config.name;
    this.maxSize = config.maxSize || 1000;
    this.priority = config.priority || 5;
    this.ttl = config.ttl || 60000; // Default TTL: 60 seconds
    this.logger = config.logger;
    
    // Initialize LRU cache
    this.cache = new LRUCache(this.maxSize);
    
    // Timestamp tracking for data expiration
    this.timestamps = new Map();
    
    // Statistics
    this.stats = {
      hits: 0,
      misses: 0,
      evictions: 0,
      expirations: 0,
      totalItems: 0,
      maxItemsReached: 0
    };
  }

  /**
   * Add item to buffer
   * @param {string} key - Unique identifier for item
   * @param {*} data - Data to store
   * @param {Object} options - Additional options
   * @param {number} options.ttl - Time-to-live in ms (overrides default)
   */
  add(key, data, options = {}) {
    const currentSize = this.cache.size();
    const now = Date.now();
    
    // Track when item was added for TTL
    this.timestamps.set(key, {
      added: now,
      expires: now + (options.ttl || this.ttl)
    });
    
    // Add to cache
    this.cache.put(key, data);
    
    // Update stats
    this.stats.totalItems++;
    if (currentSize === this.maxSize) {
      this.stats.evictions++;
      this.stats.maxItemsReached++;
    }
    
    // Log if we're at capacity
    if (currentSize >= this.maxSize) {
      this.logger.debug(`[MemoryManager] ${this.name} buffer at capacity (${this.maxSize} items)`);
    }
  }

  /**
   * Get item from buffer
   * @param {string} key - Unique identifier for item
   * @returns {*} - Stored data or null if not found
   */
  get(key) {
    const timestamp = this.timestamps.get(key);
    const now = Date.now();
    
    // Check if item exists
    if (!timestamp) {
      this.stats.misses++;
      return null;
    }
    
    // Check if item has expired
    if (timestamp.expires < now) {
      this.delete(key);
      this.stats.expirations++;
      this.stats.misses++;
      return null;
    }
    
    // Get from cache
    const data = this.cache.get(key);
    if (data) {
      this.stats.hits++;
      return data;
    } else {
      this.stats.misses++;
      return null;
    }
  }

  /**
   * Delete item from buffer
   * @param {string} key - Unique identifier for item
   */
  delete(key) {
    this.cache.delete(key);
    this.timestamps.delete(key);
  }

  /**
   * Clear expired items
   * @returns {number} - Number of items cleared
   */
  clearExpired() {
    const now = Date.now();
    let cleared = 0;
    
    // Identify expired keys
    const expiredKeys = [];
    this.timestamps.forEach((timestamp, key) => {
      if (timestamp.expires < now) {
        expiredKeys.push(key);
      }
    });
    
    // Remove expired keys
    for (const key of expiredKeys) {
      this.delete(key);
      cleared++;
    }
    
    if (cleared > 0) {
      this.stats.expirations += cleared;
      this.logger.debug(`[MemoryManager] Cleared ${cleared} expired items from ${this.name} buffer`);
    }
    
    return cleared;
  }

  /**
   * Prune least recently used items to target size
   * @param {number} targetSize - Target buffer size after pruning
   * @returns {number} - Number of items pruned
   */
  prune(targetSize) {
    if (targetSize >= this.cache.size()) {
      return 0;
    }
    
    const toPrune = this.cache.size() - targetSize;
    const lruKeys = this.cache.getLRUKeys(toPrune);
    
    for (const key of lruKeys) {
      this.delete(key);
    }
    
    this.stats.evictions += lruKeys.length;
    this.logger.debug(`[MemoryManager] Pruned ${lruKeys.length} items from ${this.name} buffer`);
    
    return lruKeys.length;
  }

  /**
   * Get buffer stats
   * @returns {Object} - Buffer statistics
   */
  getStats() {
    return {
      ...this.stats,
      currentSize: this.cache.size(),
      maxSize: this.maxSize,
      utilization: this.cache.size() / this.maxSize
    };
  }
}

/**
 * Main MemoryManager class
 */
export class MemoryManager {
  /**
   * Create a new MemoryManager
   * @param {Object} config - Configuration options
   */
  constructor(config = {}) {
    // Default configuration
    this.config = {
      maxMemoryUsage: config.maxMemoryUsage || 512 * 1024 * 1024, // 512MB default
      warningThreshold: config.warningThreshold || 0.8,        // 80% usage triggers warnings
      criticalThreshold: config.criticalThreshold || 0.95,     // 95% triggers aggressive pruning
      checkInterval: config.checkInterval || 30000,           // Check memory every 30s
      symbol: config.symbol || 'unknown',
      ...config
    };
    
    // Initialize logger
    this.logger = config.logger || new TradingLogger({
      component: 'MemoryManager',
      symbol: this.config.symbol
    });
    
    // Initialize buffers for different data types
    this.buffers = {
      orderbook: new BufferManager({
        name: 'orderbook',
        maxSize: config.orderbookMaxSize || 5000,
        priority: 10, // Higher number = higher priority
        ttl: config.orderbookTTL || 300000, // 5 minutes default
        logger: this.logger
      }),
      
      trades: new BufferManager({
        name: 'trades',
        maxSize: config.tradesMaxSize || 10000,
        priority: 8,
        ttl: config.tradesTTL || 3600000, // 1 hour default
        logger: this.logger
      }),
      
      orders: new BufferManager({
        name: 'orders',
        maxSize: config.ordersMaxSize || 1000,
        priority: 9,
        ttl: config.ordersTTL || 86400000, // 24 hours default
        logger: this.logger
      }),
      
      balances: new BufferManager({
        name: 'balances',
        maxSize: config.balancesMaxSize || 100,
        priority: 10,
        ttl: config.balancesTTL || 300000, // 5 minutes default
        logger: this.logger
      })
    };
    
    // Start memory monitor
    this.memoryCheckInterval = setInterval(() => {
      this.checkMemoryUsage();
    }, this.config.checkInterval);
    
    // Start cleanup monitor for expired items
    this.cleanupInterval = setInterval(() => {
      this.clearExpiredItems();
    }, Math.min(60000, this.config.checkInterval)); // At least once per minute
    
    this.logger.info('MemoryManager initialized', {
      maxMemoryUsage: this.formatBytes(this.config.maxMemoryUsage),
      warningThreshold: `${this.config.warningThreshold * 100}%`,
      criticalThreshold: `${this.config.criticalThreshold * 100}%`
    });
  }

  /**
   * Add orderbook data to buffer
   * @param {string} key - Unique identifier (usually symbol+timestamp)
   * @param {Object} data - Orderbook data
   * @param {Object} options - Additional options
   */
  addOrderbook(key, data, options = {}) {
    this.logger.error('[MemoryManager ORDERBOOK_DEBUG] Adding orderbook to buffer', {
      key,
      hasData: !!data,
      dataType: typeof data,
      dataKeys: data ? Object.keys(data) : null,
      hasBids: !!(data?.bids && data.bids.length > 0),
      hasAsks: !!(data?.asks && data.asks.length > 0),
      bidCount: data?.bids?.length || 0,
      askCount: data?.asks?.length || 0,
      timestamp: data?.timestamp,
      options,
      bufferCurrentSize: this.buffers.orderbook.cache.size(),
      bufferMaxSize: this.buffers.orderbook.maxSize
    });
    
    this.buffers.orderbook.add(key, data, options);
    
    this.logger.error('[MemoryManager ORDERBOOK_DEBUG] Orderbook added to buffer', {
      key,
      bufferNewSize: this.buffers.orderbook.cache.size(),
      addedSuccessfully: true
    });
  }

  /**
   * Get orderbook data from buffer
   * @param {string} key - Unique identifier
   * @returns {Object} - Orderbook data or null
   */
  getOrderbook(key) {
    const result = this.buffers.orderbook.get(key);
    
    this.logger.error('[MemoryManager ORDERBOOK_DEBUG] Getting orderbook from buffer', {
      key,
      found: !!result,
      resultType: typeof result,
      bufferCurrentSize: this.buffers.orderbook.cache.size(),
      bufferStats: this.buffers.orderbook.getStats()
    });
    
    return result;
  }

  /**
   * Add trade data to buffer
   * @param {string} key - Unique identifier
   * @param {Object} data - Trade data
   * @param {Object} options - Additional options
   */
  addTrade(key, data, options = {}) {
    this.buffers.trades.add(key, data, options);
  }

  /**
   * Get trade data from buffer
   * @param {string} key - Unique identifier
   * @returns {Object} - Trade data or null
   */
  getTrade(key) {
    return this.buffers.trades.get(key);
  }

  /**
   * Add order data to buffer
   * @param {string} key - Unique identifier
   * @param {Object} data - Order data
   * @param {Object} options - Additional options
   */
  addOrder(key, data, options = {}) {
    this.buffers.orders.add(key, data, options);
  }

  /**
   * Get order data from buffer
   * @param {string} key - Unique identifier
   * @returns {Object} - Order data or null
   */
  getOrder(key) {
    return this.buffers.orders.get(key);
  }

  /**
   * Add balance data to buffer
   * @param {string} key - Unique identifier
   * @param {Object} data - Balance data
   * @param {Object} options - Additional options
   */
  addBalance(key, data, options = {}) {
    this.buffers.balances.add(key, data, options);
  }

  /**
   * Get balance data from buffer
   * @param {string} key - Unique identifier
   * @returns {Object} - Balance data or null
   */
  getBalance(key) {
    return this.buffers.balances.get(key);
  }
  
  /**
   * Generic method to set any type of data in the memory manager
   * @param {string} key - Unique identifier
   * @param {*} data - Any data to store
   * @param {number} ttlSeconds - Time to live in seconds (optional)
   * @returns {boolean} - Success status
   */
  set(key, data, ttlSeconds = 3600) {
    try {
      // Determine the data type from the key prefix
      if (key.startsWith('orderbook:')) {
        this.addOrderbook(key, data, { ttl: ttlSeconds * 1000 });
      } else if (key.startsWith('trade:')) {
        this.addTrade(key, data, { ttl: ttlSeconds * 1000 });
      } else if (key.startsWith('order:')) {
        this.addOrder(key, data, { ttl: ttlSeconds * 1000 });
      } else if (key.startsWith('balance:')) {
        this.addBalance(key, data, { ttl: ttlSeconds * 1000 });
      } else {
        // For performance metrics and other generic data, use a fallback buffer
        if (!this.buffers.generic) {
          // Initialize generic buffer if it doesn't exist
          this.buffers.generic = new BufferManager({
            name: 'generic',
            maxSize: 10000,
            priority: 5, // Lower priority than core trading data
            ttl: 3600000, // 1 hour default
            logger: this.logger
          });
        }
        this.buffers.generic.add(key, data, { ttl: ttlSeconds * 1000 });
      }
      return true;
    } catch (error) {
      this.logger.warn('Failed to set data in memory manager', { key, error: error.message });
      return false;
    }
  }
  
  /**
   * Generic method to get any type of data from the memory manager
   * @param {string} key - Unique identifier
   * @returns {*} - Stored data or null
   */
  get(key) {
    try {
      // Determine the data type from the key prefix
      if (key.startsWith('orderbook:')) {
        return this.getOrderbook(key);
      } else if (key.startsWith('trade:')) {
        return this.getTrade(key);
      } else if (key.startsWith('order:')) {
        return this.getOrder(key);
      } else if (key.startsWith('balance:')) {
        return this.getBalance(key);
      } else if (this.buffers.generic) {
        // For performance metrics and other generic data
        return this.buffers.generic.get(key);
      }
      return null;
    } catch (error) {
      this.logger.warn('Failed to get data from memory manager', { key, error: error.message });
      return null;
    }
  }

  /**
   * Check current memory usage and take action if needed
   */
  checkMemoryUsage() {
    // Get current memory usage stats
    const memUsage = process.memoryUsage();
    const heapUsedPercent = memUsage.heapUsed / this.config.maxMemoryUsage;
    
    // Format for logging
    const stats = {
      heapUsed: this.formatBytes(memUsage.heapUsed),
      heapTotal: this.formatBytes(memUsage.heapTotal),
      rss: this.formatBytes(memUsage.rss),
      maxAllowed: this.formatBytes(this.config.maxMemoryUsage),
      usedPercent: `${(heapUsedPercent * 100).toFixed(2)}%`
    };
    
    if (heapUsedPercent > this.config.criticalThreshold) {
      // Critical memory pressure - aggressive pruning
      this.logger.warn('Critical memory pressure detected', stats);
      this.pruneAllBuffers(0.5); // Reduce all buffers by 50%
    } else if (heapUsedPercent > this.config.warningThreshold) {
      // Warning level - moderate pruning of low priority buffers
      this.logger.warn('High memory usage detected', stats);
      this.pruneBuffersByPriority(0.7); // Reduce lower priority buffers by 30%
    } else {
      // Normal operation - just log stats
      this.logger.debug('Memory usage normal', stats);
    }
  }

  /**
   * Clear all expired items from all buffers
   */
  clearExpiredItems() {
    let totalCleared = 0;
    
    // Clear expired items from each buffer
    for (const [name, buffer] of Object.entries(this.buffers)) {
      const cleared = buffer.clearExpired();
      totalCleared += cleared;
    }
    
    if (totalCleared > 0) {
      this.logger.debug(`Cleared ${totalCleared} expired items across all buffers`);
    }
  }

  /**
   * Prune all buffers to a percentage of their current size
   * @param {number} percent - Target percentage (0.5 = reduce to 50%)
   */
  pruneAllBuffers(percent) {
    for (const [name, buffer] of Object.entries(this.buffers)) {
      const currentSize = buffer.cache.size();
      const targetSize = Math.floor(currentSize * percent);
      buffer.prune(targetSize);
    }
    
    this.logger.info(`Pruned all buffers to ${percent * 100}% of their previous size`);
  }

  /**
   * Prune buffers based on their priority
   * @param {number} percent - Target percentage for lowest priority
   */
  pruneBuffersByPriority(percent) {
    // Get sorted buffers by priority (lowest first)
    const buffersByPriority = Object.entries(this.buffers)
      .sort(([nameA, bufferA], [nameB, bufferB]) => 
        bufferA.priority - bufferB.priority
      );
    
    // Prune each buffer with a scaling factor based on priority
    buffersByPriority.forEach(([name, buffer], index) => {
      // Scale percentage based on position in priority list
      // Lower priority buffers get pruned more aggressively
      const scaleFactor = percent + ((1 - percent) * (index / buffersByPriority.length));
      const currentSize = buffer.cache.size();
      const targetSize = Math.floor(currentSize * scaleFactor);
      
      const pruned = buffer.prune(targetSize);
      if (pruned > 0) {
        this.logger.debug(`Pruned ${pruned} items from ${name} buffer (priority ${buffer.priority})`);
      }
    });
  }

  /**
   * Get stats for all buffers
   * @returns {Object} - Buffer statistics
   */
  getStats() {
    const stats = {};
    for (const [name, buffer] of Object.entries(this.buffers)) {
      stats[name] = buffer.getStats();
    }
    return stats;
  }

  /**
   * Format bytes to human-readable string
   * @param {number} bytes - Bytes to format
   * @returns {string} - Formatted string
   */
  formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  }

  /**
   * Get all keys from all buffer types
   * @param {string|null} prefix - Optional prefix to filter keys by
   * @returns {Array} - Array of all keys matching the prefix
   */
  getAllKeys(prefix = null) {
    try {
      const allKeys = [];
      
      // Get keys from each buffer type
      for (const [bufferName, buffer] of Object.entries(this.buffers)) {
        if (buffer && buffer.cache) {
          // Get keys from the LRU cache
          const bufferKeys = buffer.cache.keys();
          
          // Add each key to the results
          for (const key of bufferKeys) {
            if (!prefix || key.startsWith(prefix)) {
              allKeys.push(key);
            }
          }
        }
      }
      
      return allKeys;
    } catch (error) {
      this.logger.warn('Error getting all keys from memory manager', { 
        error: error.message,
        stack: error.stack
      });
      return [];
    }
  }

  /**
   * Cleanup resources when no longer needed
   */
  cleanup() {
    // Clear intervals
    clearInterval(this.memoryCheckInterval);
    clearInterval(this.cleanupInterval);
    
    // Log final stats
    this.logger.info('MemoryManager shutting down', this.getStats());
  }
}

export default MemoryManager;
