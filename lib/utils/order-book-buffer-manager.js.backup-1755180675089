/**
 * OrderBookBufferManager
 * 
 * Manages orderbook data with efficient buffering, validation, and analysis.
 * Derived from our traditional strategy's orderbook management approach
 * but adapted for the threaded architecture.
 * 
 * Features:
 * - Orderbook validation and normalization
 * - Time-windowed analysis (e.g., 250ms lookback)
 * - Averaged metrics calculation
 * - Price change detection
 */

import { TradingLogger } from '../../../utils/trading-logger.js';
import { EventEmitter } from 'events';
import { SpreadCalculator } from './spread-calculator.js';

class OrderBookBufferManager {
  /**
   * Create a new OrderBookBufferManager
   * @param {Object} config Configuration options
   */
  constructor(config = {}) {
    // --- BEGIN ADDED DIAGNOSTIC LOGGING (HANDOFF STEP 6.A) ---
    const initialLoggerForOBBM = config.logger || new TradingLogger({ component: 'OrderBookBufferManager_FallbackInit', symbol: config.symbol || 'unknown_symbol_init' });
    initialLoggerForOBBM.error('[OBBM_CONSTRUCTOR_DEBUG] STEP 0: Constructor invoked.', { configKeys: Object.keys(config) });

    this.symbol = config.symbol || 'unknown';
    this.logger = config.logger || new TradingLogger({
      component: 'OrderBookBufferManager',
      symbol: this.symbol
    });
    this.logger.error('[OBBM_CONSTRUCTOR_DEBUG] STEP 1: this.logger assigned.', { loggerName: this.logger.name, loggerComponent: this.logger.component });
    
    this.logger.error('[OBBM_CONSTRUCTOR_DEBUG] STEP 2a: About to instantiate SpreadCalculator. Checking this.logger.createChild.', {
      typeofCreateChild: typeof this.logger.createChild,
      isLoggerAFunction: typeof this.logger === 'function'
    });
    // Initialize SpreadCalculator for standardized spread calculations
    this.spreadCalculator = new SpreadCalculator({
      logger: this.logger.createChild('SpreadCalculator'),
      debug: config.debug || false
    });
    this.logger.error('[OBBM_CONSTRUCTOR_DEBUG] STEP 2b: SpreadCalculator instantiated.', { spreadCalculatorKeys: Object.keys(this.spreadCalculator) });

    this.memoryManager = config.memoryManager;
    this.logger.error('[OBBM_CONSTRUCTOR_DEBUG] STEP 3: this.memoryManager assigned.', { memoryManagerIsPresent: !!this.memoryManager, typeofMemoryManager: typeof this.memoryManager });
    // --- END ADDED DIAGNOSTIC LOGGING ---
    
    // Configuration
    this.bufferTimeWindow = config.bufferTimeWindow || 900000; // 15 minutes buffer
    this.analysisTimeWindow = config.analysisTimeWindow || 250; // 250ms analysis window
    this.maxCrossedSpread = config.maxCrossedSpread || 0.0001; // 0.01% maximum crossed amount
    
    // Internal state
    this.lastSnapshot = null;
    this.lastBestBid = 0;
    this.lastBestAsk = 0;
    this.lastBidUpdateTime = 0;
    this.lastAskUpdateTime = 0;
    this.orderBookBuffer = []; // Initialize the orderBookBuffer as an empty array
    
    this.logger.info('OrderBookBufferManager initialized', {
      symbol: this.symbol,
      bufferTimeWindow: this.bufferTimeWindow,
      analysisTimeWindow: this.analysisTimeWindow
    });

    // --- BEGIN ADDED DIAGNOSTIC LOGGING (HANDOFF STEP 6.A - END OF CONSTRUCTOR) ---
    this.logger.error('[OBBM_CONSTRUCTOR_DEBUG] STEP 4: End of constructor checks.', {
      typeof_getLatestOrderbook: typeof this.getLatestOrderbook,
      typeof_calculateAveragedMetrics: typeof this.calculateAveragedMetrics,
      this_objectKeys: JSON.stringify(Object.keys(this)),
      isPrototypeOf_OrderBookBufferManager_prototype: Object.getPrototypeOf(this) === OrderBookBufferManager.prototype,
      isInstanceof_OrderBookBufferManager: this instanceof OrderBookBufferManager
    });
    // --- END ADDED DIAGNOSTIC LOGGING ---
  }
  
  /**
   * Process and store an orderbook in the buffer
   * @param {Object} rawOrderBook Raw orderbook data
   * @returns {Object|null} Processed orderbook or null if invalid
   */
  processAndStoreOrderBook(rawOrderBook) {
    // TEMPORARY: Add debug logging
    this.logger.info('[OBBM] processAndStoreOrderBook called', {
      hasOrderBook: !!rawOrderBook,
      symbol: rawOrderBook?.symbol,
      bidCount: rawOrderBook?.bids?.length,
      askCount: rawOrderBook?.asks?.length
    });
    
    if (!rawOrderBook) {
      this.logger.debug('Received null or undefined orderbook');
      return null;
    }
    
    try {
      // Ensure required fields exist
      if (!rawOrderBook.bids || !rawOrderBook.asks) {
        this.logger.debug('Orderbook missing required bid/ask fields');
        return null;
      }
      
      // Deep clone to avoid modifying the original
      const processedBook = {
        bids: [...rawOrderBook.bids],
        asks: [...rawOrderBook.asks],
        timestamp: rawOrderBook.timestamp || Date.now()
      };
      
      // Ensure proper format: [price, volume] for each level
      processedBook.bids = processedBook.bids.map(bid => {
        // Handle different possible formats
        if (Array.isArray(bid)) {
          return [String(bid[0]), String(bid[1])]; // Convert to string format
        } else if (typeof bid === 'object') {
          return [String(bid.price), String(bid.volume)];
        }
        return null;
      }).filter(bid => bid !== null);
      
      processedBook.asks = processedBook.asks.map(ask => {
        // Handle different possible formats
        if (Array.isArray(ask)) {
          return [String(ask[0]), String(ask[1])]; // Convert to string format
        } else if (typeof ask === 'object') {
          return [String(ask.price), String(ask.volume)];
        }
        return null;
      }).filter(ask => ask !== null);
      
      // Sort bids descending, asks ascending
      processedBook.bids.sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]));
      processedBook.asks.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));
      
      // Ensure we have data after cleaning
      if (processedBook.bids.length === 0 || processedBook.asks.length === 0) {
        this.logger.debug('No valid bid or ask levels after processing');
        return null;
      }
      
      // Check for crossed book (bid >= ask)
      const bestBid = parseFloat(processedBook.bids[0][0]);
      const bestAsk = parseFloat(processedBook.asks[0][0]);
      
      if (bestBid >= bestAsk) {
        this.logger.debug(`Crossed orderbook detected: bid ${bestBid} >= ask ${bestAsk}`);
        
        // Try to fix crossed book
        if (this.lastBidUpdateTime > this.lastAskUpdateTime) {
          // Bid data is newer, adjust asks
          const minValidAsk = bestBid * (1 + this.maxCrossedSpread);
          processedBook.asks = processedBook.asks.filter(ask => parseFloat(ask[0]) >= minValidAsk);
        } else {
          // Ask data is newer, adjust bids
          const maxValidBid = bestAsk * (1 - this.maxCrossedSpread);
          processedBook.bids = processedBook.bids.filter(bid => parseFloat(bid[0]) <= maxValidBid);
        }
        
        // Re-sort and check if still valid
        processedBook.bids.sort((a, b) => parseFloat(b[0]) - parseFloat(a[0]));
        processedBook.asks.sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));
        
        if (processedBook.bids.length === 0 || processedBook.asks.length === 0) {
          this.logger.debug('No valid levels after fixing crossed book');
          return null;
        }
      }
      
      // Update timestamps
      const currentTime = Date.now();
      this.lastBidUpdateTime = currentTime;
      this.lastAskUpdateTime = currentTime;
      
      // Calculate metrics using standardized SpreadCalculator
      const updatedBestBid = parseFloat(processedBook.bids[0][0]);
      const updatedBestAsk = parseFloat(processedBook.asks[0][0]);
      const midPrice = (updatedBestBid + updatedBestAsk) / 2;
      
      // Use the spread calculator for consistent spread calculations
      const marketData = {
        bestBid: updatedBestBid,
        bestAsk: updatedBestAsk,
        midPrice: midPrice
      };
      
      const spreadResult = this.spreadCalculator.calculateMarketBasedSpread(marketData, null, false);
      
      // Raw spread (absolute difference)
      const spread = updatedBestAsk - updatedBestBid;
      
      // Get standardized spread percentage from calculator (more accurate)
      const spreadPercentage = spreadResult.spreadPercentage * 100; // Convert decimal to percentage
      
      // Keep basis points for backward compatibility
      const spreadBps = spreadPercentage * 100; // Convert percentage to basis points
      
      // Add metrics to the processed book
      processedBook.midPrice = midPrice;
      processedBook.spread = spread;
      processedBook.spreadPercentage = spreadPercentage;
      processedBook.spreadBps = spreadBps;
      processedBook.spreadFromCalculator = true; // Add flag to indicate standard calculation
      processedBook.depth = {
        bid: processedBook.bids.length,
        ask: processedBook.asks.length
      };
      
      // Track price changes
      if (this.lastBestBid > 0 && this.lastBestAsk > 0) {
        processedBook.priceChanges = {
          bid: updatedBestBid - this.lastBestBid,
          ask: updatedBestAsk - this.lastBestAsk,
          mid: midPrice - ((this.lastBestBid + this.lastBestAsk) / 2)
        };
      } else {
        processedBook.priceChanges = { bid: 0, ask: 0, mid: 0 };
      }
      
      // Update last values
      this.lastBestBid = updatedBestBid;
      this.lastBestAsk = updatedBestAsk;
      this.lastSnapshot = processedBook;
      
      // Add to buffer array
      this.orderBookBuffer.push(processedBook);
      
      // Keep buffer size within limits
      const maxBufferSize = 100;
      if (this.orderBookBuffer.length > maxBufferSize) {
        this.orderBookBuffer = this.orderBookBuffer.slice(-maxBufferSize);
      }
      
      // TEMPORARY: Log buffer addition
      this.logger.info('[OBBM] Added orderbook to buffer', {
        bufferLength: this.orderBookBuffer.length,
        timestamp: processedBook.timestamp
      });
      
      // Store in memory manager if available
      if (this.memoryManager) {
        const orderbookKey = `orderbook:${this.symbol}:${processedBook.timestamp}`;
        this.memoryManager.addOrderbook(orderbookKey, processedBook);
        this.memoryManager.set('current_orderbook_key', orderbookKey);
        this.memoryManager.set('latest_market_data_timestamp', processedBook.timestamp);
        
        this.logger.debug(`Stored processed orderbook in buffer with key ${orderbookKey}`);
      } else {
        this.logger.warn('No memory manager available for orderbook storage');
      }
      
      // TEMPORARY: Log successful processing
      this.logger.info('[OBBM] Successfully processed orderbook', {
        bufferSize: this.orderBookBuffer.length,
        midPrice: processedBook.midPrice,
        spread: processedBook.spread
      });
      
      return processedBook;
    } catch (error) {
      this.logger.error('Error processing orderbook', {
        error: error.message,
        stack: error.stack
      });
      return null;
    }
  }
  
  /**
   * Get recent orderbooks from the buffer
   * @param {number} timeWindowMs Time window in milliseconds
   * @returns {Array} Array of recent orderbook entries
   */
  getRecentOrderbooks(timeWindowMs = null) {
    // Use default analysis window if not specified
    const windowMs = timeWindowMs || this.analysisTimeWindow;
    
    this.logger.error('[OBBM:getRecentOrderbooks DEBUG_ENTRY]', { // .error for visibility
      requestedWindowMs: windowMs,
      bufferLength: this.orderBookBuffer ? this.orderBookBuffer.length : 0,
      hasMemoryManager: !!this.memoryManager
    });
    
    try {
      // Use the internal orderBookBuffer instead of MemoryManager
      if (!this.orderBookBuffer || this.orderBookBuffer.length === 0) {
        this.logger.debug('No orderbooks in internal buffer');
        
        // Fallback to MemoryManager only if internal buffer is empty
        if (!this.memoryManager) {
          this.logger.warn('No memory manager available and internal buffer is empty');
          return this.lastSnapshot ? [this.lastSnapshot] : [];
        }
        
        // Try MemoryManager as fallback
        const currentOrderbookKey = this.memoryManager.get('current_orderbook_key');
        if (currentOrderbookKey) {
          const orderbook = this.memoryManager.getOrderbook(currentOrderbookKey);
          if (orderbook) {
            this.logger.debug(`Retrieved orderbook from MemoryManager using key: ${currentOrderbookKey}`);
            return [orderbook];
          }
        }
        
        return [];
      }
      
      const cutoffTime = Date.now() - windowMs;
      const recentOrderbooks = [];
      
      // Filter orderbooks from internal buffer within time window
      for (const book of this.orderBookBuffer) {
        if (book.timestamp >= cutoffTime) {
          recentOrderbooks.push(book);
        }
      }
      
      this.logger.error('[OBBM:getRecentOrderbooks DEBUG_RESULT]', { // .error for visibility
        foundRecentBooks: recentOrderbooks.length,
        cutoffTime: cutoffTime,
        windowMs: windowMs,
        sampleTimestamp: recentOrderbooks.length > 0 ? recentOrderbooks[0].timestamp : 'none'
      });
      
      this.logger.debug(`Retrieved ${recentOrderbooks.length} orderbooks from internal buffer (last ${windowMs}ms)`);
      return recentOrderbooks;
      
    } catch (error) {
      this.logger.error('Error retrieving recent orderbooks', {
        error: error.message,
        stack: error.stack
      });
      return [];
    }
  }
  
  /**
   * Calculate averaged metrics from recent orderbooks
   * @param {number} timeWindowMs Time window in milliseconds (default: uses class default)
   * @returns {Object} Averaged orderbook metrics
   */
  calculateAveragedMetrics(timeWindowMs = null) {
    const actualTimeWindowMs = timeWindowMs || this.analysisTimeWindow;
    this.logger.error('[OBBM:calculateAveragedMetrics DEBUG_PARAMS]', { // .error for visibility
      requestedTimeWindowMs: timeWindowMs,
      actualTimeWindowMs: actualTimeWindowMs,
      currentBufferLength: this.orderBookBuffer ? this.orderBookBuffer.length : 0
    });

    const recentOrderbooks = this.getRecentOrderbooks(actualTimeWindowMs);
    
    this.logger.error('[OBBM:calculateAveragedMetrics DEBUG_INPUT]', { // .error for visibility
      countRecentOrderbooks: recentOrderbooks.length,
      recentOrderbooksSample: recentOrderbooks.length > 0 ? JSON.stringify(recentOrderbooks.slice(0, 2)) : 'empty' // Log first 2 samples
    });

    // Default metrics if no data available
    const defaultMetrics = {
      bestBid: this.lastBestBid || 0,
      bestAsk: this.lastBestAsk || 0,
      midPrice: (this.lastBestBid + this.lastBestAsk) / 2 || 0,
      spread: this.lastBestAsk - this.lastBestBid || 0,
      spreadBps: ((this.lastBestAsk - this.lastBestBid) / this.lastBestBid) * 10000 || 0,
      bidVolume: 0,
      askVolume: 0,
      volumeImbalance: 0,
      bidDepth: 0,
      askDepth: 0,
      bidChanges: 0,
      askChanges: 0,
      timestamp: Date.now(),
      dataPoints: 0
    };
    
    if (recentOrderbooks.length === 0) {
      this.logger.debug('No recent orderbooks available for averaging');
      this.logger.error('[OBBM:calculateAveragedMetrics DEBUG_NO_RECENT_BOOKS]', { // .error for visibility
        returningDefaultMetrics: true,
        lastBestBid: this.lastBestBid,
        lastBestAsk: this.lastBestAsk,
        bufferSize: this.orderBookBuffer.length, 
        actualTimeWindowMsUsed: actualTimeWindowMs 
      });
      return defaultMetrics;
    }
    
    try {
      let totalBestBid = 0;
      let totalBestAsk = 0;
      let totalMidPrice = 0;
      let totalSpread = 0;
      let totalSpreadBps = 0;
      let totalBidVolume = 0;
      let totalAskVolume = 0;
      let totalBidDepth = 0;
      let totalAskDepth = 0;
      let totalBidChanges = 0;
      let totalAskChanges = 0;
      let validEntries = 0;
      
      // Track price changes between consecutive entries
      let previousBid = null;
      let previousAsk = null;
      let totalPriceChanges = 0;
      
      // Process each orderbook
      for (const book of recentOrderbooks) {
        // Ensure we have all required data
        if (!book.bids || !book.asks || book.bids.length === 0 || book.asks.length === 0) {
          this.logger.warn('[OBBM:calculateAveragedMetrics DEBUG_SKIPPING_BOOK]', { bookTimestamp: book.timestamp, reason: 'Missing bids/asks' });
          continue;
        }
        
        // Prefer direct properties if they exist, otherwise fallback to array access
        const rawBestBid = book.bestBid !== undefined ? book.bestBid : (book.bids && book.bids.length > 0 ? book.bids[0][0] : undefined);
        const rawBestAsk = book.bestAsk !== undefined ? book.bestAsk : (book.asks && book.asks.length > 0 ? book.asks[0][0] : undefined);
        const rawMidPrice = book.midPrice; // Assume midPrice is pre-calculated or can be NaN

        this.logger.error('[OBBM:calculateAveragedMetrics DEBUG_BOOK_VALUES_PRE_FLOAT]', { // .error for visibility
          originalBestBid: rawBestBid,
          originalBestAsk: rawBestAsk,
          originalMidPrice: rawMidPrice,
          typeOfBestBid: typeof rawBestBid,
          typeOfBestAsk: typeof rawBestAsk,
          typeOfMidPrice: typeof rawMidPrice,
          timestamp: book.timestamp
        });

        const bookBestBid = parseFloat(rawBestBid);
        const bookBestAsk = parseFloat(rawBestAsk);
        const bookMidPrice = parseFloat(rawMidPrice);
        
        this.logger.error('[OBBM:calculateAveragedMetrics DEBUG_BOOK_VALUES_POST_FLOAT]', { // .error for visibility
          parsedBestBid: bookBestBid,
          parsedBestAsk: bookBestAsk,
          parsedMidPrice: bookMidPrice,
          timestamp: book.timestamp
        });

        if (isNaN(bookBestBid) || isNaN(bookBestAsk)) { // MidPrice can be NaN if not calculable, but bid/ask are crucial
          this.logger.warn('[OBBM:calculateAveragedMetrics DEBUG_NAN_IN_BOOK_VALUES]', {
            bookTimestamp: book.timestamp,
            bestBid: bookBestBid,
            bestAsk: bookBestAsk,
            midPrice: bookMidPrice
          });
          continue; // Skip this book if essential values are NaN
        }
        
        // Skip crossed books
        if (bookBestBid >= bookBestAsk) {
          continue;
        }
        
        // Calculate mid price and spread
        const midPrice = book.midPrice || (bookBestBid + bookBestAsk) / 2;
        const spread = book.spread || (bookBestAsk - bookBestBid);
        const spreadBps = book.spreadBps || (spread / midPrice) * 10000;
        
        // Accumulate values
        totalBestBid += bookBestBid;
        totalBestAsk += bookBestAsk;
        totalMidPrice += midPrice;
        totalSpread += spread;
        totalSpreadBps += spreadBps;
        const bidVolume = parseFloat(book.bids[0][1]);
        const askVolume = parseFloat(book.asks[0][1]);
        
        // Accumulate depth information
        totalBidDepth += book.depth?.bid || book.bids.length;
        totalAskDepth += book.depth?.ask || book.asks.length;
        
        // Track price changes if we have them
        if (book.priceChanges) {
          totalBidChanges += Math.abs(book.priceChanges.bid);
          totalAskChanges += Math.abs(book.priceChanges.ask);
        }
        
        // Track consecutive price changes
        if (previousBid !== null && previousAsk !== null) {
          totalPriceChanges++;
        }
        previousBid = bookBestBid;
        previousAsk = bookBestAsk;
        
        validEntries++;
      }
      
      // Calculate averages
      if (validEntries > 0) {
        const result = {
          bestBid: totalBestBid / validEntries,
          bestAsk: totalBestAsk / validEntries,
          midPrice: totalMidPrice / validEntries,
          spread: totalSpread / validEntries,
          spreadBps: totalSpreadBps / validEntries,
          bidVolume: totalBidVolume / validEntries,
          askVolume: totalAskVolume / validEntries,
          volumeImbalance: (totalBidVolume - totalAskVolume) / (totalBidVolume + totalAskVolume),
          bidDepth: totalBidDepth / validEntries,
          askDepth: totalAskDepth / validEntries,
          bidChanges: totalBidChanges / validEntries,
          askChanges: totalAskChanges / validEntries,
          timestamp: Date.now(),
          dataPoints: validEntries
        };
        
        this.logger.debug(`Calculated averaged metrics from ${validEntries} orderbooks`);
        this.logger.error('[OBBM:calculateAveragedMetrics DEBUG_RESULT]', { // .error for visibility
          result: JSON.stringify(result),
          validEntries
        });
        return result;
      }
      
      this.logger.debug('No valid entries for calculating averages');
      this.logger.error('[OBBM:calculateAveragedMetrics DEBUG_NO_VALID_ENTRIES]', { // .error for visibility
        returningDefaultMetrics: true,
        lastBestBid: this.lastBestBid,
        lastBestAsk: this.lastBestAsk,
        totalRecentBooks: recentOrderbooks.length
      });
      return defaultMetrics;
      
    } catch (error) {
      this.logger.error('Error calculating averaged metrics', {
        error: error.message,
        stack: error.stack
      });
      this.logger.error('[OBBM:calculateAveragedMetrics DEBUG_ERROR_CASE]', { // .error for visibility
        returningDefaultMetricsDueToError: true,
        lastBestBid: this.lastBestBid,
        lastBestAsk: this.lastBestAsk
      });
      return defaultMetrics;
    }
  }
  
  /**
   * Detect price changes from previous snapshot
   * @returns {Object} Price change information
   */
  detectPriceChanges() {
    if (!this.lastSnapshot) {
      return { bid: 0, ask: 0, mid: 0, detected: false };
    }
    
    try {
      // Get most recent orderbook
      const recentOrderbooks = this.getRecentOrderbooks(100); // Use last 100ms
      
      if (recentOrderbooks.length === 0) {
        return { bid: 0, ask: 0, mid: 0, detected: false };
      }
      
      const latest = recentOrderbooks[0];
      
      const bestBid = latest.bestBid || parseFloat(latest.bids[0][0]);
      const bestAsk = latest.bestAsk || parseFloat(latest.asks[0][0]);
      const midPrice = (bestBid + bestAsk) / 2;
      
      const lastBestBid = this.lastSnapshot.bestBid || parseFloat(this.lastSnapshot.bids[0][0]);
      const lastBestAsk = this.lastSnapshot.bestAsk || parseFloat(this.lastSnapshot.asks[0][0]);
      const lastMidPrice = (lastBestBid + lastBestAsk) / 2;
      
      // Calculate changes
      const bidChange = bestBid - lastBestBid;
      const askChange = bestAsk - lastBestAsk;
      const midChange = midPrice - lastMidPrice;
      
      // Determine if a significant change occurred (more than 0.01%)
      const significantChange = 
        Math.abs(bidChange / lastBestBid) > 0.0001 || 
        Math.abs(askChange / lastBestAsk) > 0.0001;
      
      return {
        bid: bidChange,
        ask: askChange,
        mid: midChange,
        detected: significantChange
      };
      
    } catch (error) {
      this.logger.error('Error detecting price changes', {
        error: error.message,
        stack: error.stack
      });
      return { bid: 0, ask: 0, mid: 0, detected: false };
    }
  }
  
  /**
   * Get the latest processed orderbook snapshot from MemoryManager if available,
   * or fall back to the last locally stored snapshot.
   * This prioritizes fetching from MemoryManager to ensure consistency across components.
   * @returns {Object|null} The latest orderbook data or null if none available.
   */
  getLatestOrderbook() {
    if (this.memoryManager && typeof this.memoryManager.getAllKeys === 'function') {
      try {
        // Get all orderbook keys from memory manager
        // Corrected to use getAllKeys instead of getKeysByPrefix
        const orderbookKeys = this.memoryManager.getAllKeys('orderbook:' + this.symbol);
        
        if (orderbookKeys && orderbookKeys.length > 0) {
          // Sort keys by timestamp (assuming format orderbook:SYMBOL:timestamp)
          orderbookKeys.sort((a, b) => {
            const timeA = parseInt(a.split(':').pop(), 10);
            const timeB = parseInt(b.split(':').pop(), 10);
            return timeB - timeA; // Sort descending to get latest first
          });
          
          // Get the latest orderbook by key
          const latestKey = orderbookKeys[0];
          const latestBook = this.memoryManager.getOrderbook(latestKey);
          
          if (latestBook) {
            this.logger.debug(`Retrieved latest orderbook from MemoryManager with key: ${latestKey}`);
            this.lastSnapshot = latestBook; // Update local cache as well
            return latestBook;
          } else {
            this.logger.warn(`Failed to retrieve orderbook from MemoryManager for key: ${latestKey}`);
          }
        } else {
          this.logger.debug('No orderbook keys found in MemoryManager with prefix ' + 'orderbook:' + this.symbol);
        }
      } catch (error) {
        this.logger.error('Error getting latest orderbook from MemoryManager', { 
          error: error.message,
          stack: error.stack
        });
        // Fall through to use local lastSnapshot if MemoryManager access fails
      }
    }
    
    // Fallback to locally stored last snapshot if MemoryManager is not used or fails
    if (this.lastSnapshot) {
      this.logger.debug('Returning locally cached lastSnapshot as getLatestOrderbook.');
    } else {
      this.logger.debug('No orderbook available locally or from MemoryManager in getLatestOrderbook.');
    }
    return this.lastSnapshot;
  }

  addOrderBook(orderBook) {
    if (!orderBook || !orderBook.bids || !orderBook.asks) {
      this.logger.warn('[OBBM:addOrderBook] Received invalid or empty orderbook', { orderBook });
      return null;
    }
    // Ensure essential values are numbers before they enter the buffer if possible, or log their types
    this.logger.error('[OBBM:addOrderBook DEBUG_RAW_BOOK_INPUT]', { // .error for visibility
      symbol: orderBook.symbol,
      timestamp: orderBook.timestamp,
      firstBidPrice: orderBook.bids.length > 0 ? orderBook.bids[0][0] : 'N/A',
      firstBidQty: orderBook.bids.length > 0 ? orderBook.bids[0][1] : 'N/A',
      firstAskPrice: orderBook.asks.length > 0 ? orderBook.asks[0][0] : 'N/A',
      firstAskQty: orderBook.asks.length > 0 ? orderBook.asks[0][1] : 'N/A',
      bidsCount: orderBook.bids.length,
      asksCount: orderBook.asks.length,
      // Log the types to catch non-numeric data early
      typeOfFirstBidPrice: orderBook.bids.length > 0 ? typeof orderBook.bids[0][0] : 'N/A',
      typeOfFirstAskPrice: orderBook.asks.length > 0 ? typeof orderBook.asks[0][0] : 'N/A',
      // Log the actual bestBid/bestAsk if present on the book object itself
      bookBestBidDirect: orderBook.bestBid,
      bookBestAskDirect: orderBook.bestAsk,
      typeOfBookBestBidDirect: typeof orderBook.bestBid,
      typeOfBookBestAskDirect: typeof orderBook.bestAsk
    });

    const now = Date.now();
    
    // Create a proper processed orderbook copy
    const processedBook = {
      bids: [...orderBook.bids],
      asks: [...orderBook.asks],
      timestamp: orderBook.timestamp || now,
      symbol: orderBook.symbol || this.symbol
    };
    
    // Add to buffer and limit buffer size
    this.orderBookBuffer.push(processedBook);
    
    // TEMPORARY: Log buffer update
    this.logger.info('[OBBM] Added to buffer', {
      bufferLength: this.orderBookBuffer.length,
      timestamp: processedBook.timestamp
    });
    
    // Keep buffer size within limits
    const maxBufferSize = 100; // Limit buffer to 100 entries
    if (this.orderBookBuffer.length > maxBufferSize) {
      this.orderBookBuffer = this.orderBookBuffer.slice(-maxBufferSize);
    }
    
    // Update last snapshot
    this.lastSnapshot = processedBook;
    
    // Process and store using the existing method
    return this.processAndStoreOrderBook(orderBook);
  }
}

export default OrderBookBufferManager;
